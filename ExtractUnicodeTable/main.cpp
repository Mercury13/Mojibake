#include <iostream>
#include <fstream>
#include <charconv>
#include <map>

#include "pugixml.hpp"

unsigned fromHex(std::string_view x)
{
    long long r;
    auto beg = x.data();
    auto end = beg + x.length();
    auto res = std::from_chars(beg, end, r, 16);
    if (res.ec != std::errc() || res.ptr != end) {
        std::string errm = "[fromHex] Cannot parse hex ";
        errm.append(x);
        throw std::invalid_argument(errm);
    }
    return r;
}

constexpr int BLOCKSHIFT = 7;   // 128
constexpr int BLOCKSIZE = 1 << BLOCKSHIFT;
constexpr int BLOCKMASK = BLOCKSIZE - 1;

struct BlockInfo {
    int count = 0;
    int iArray = -1;
    int data[BLOCKSIZE] { 0 };
};

int main()
{
    try {
        std::cout << "Loading XML..." << std::flush;
        pugi::xml_document doc;
        doc.load_file("ucd.all.flat.xml");
        std::cout << "OK" << std::endl;

        auto hRoot = doc.child("ucd");
        auto hRepertoire = hRoot.child("repertoire");

        std::map<int, BlockInfo> mBlocks;

        for (auto hChar : hRepertoire.children("char")) {
            std::string_view sCf = hChar.attribute("scf").as_string();
            if (sCf.empty() || sCf == "#")
                continue;
            char32_t cf = fromHex(sCf);

            auto sCp = hChar.attribute("cp").as_string();
            char32_t cp = fromHex(sCp);

            int iBlock = cp >> BLOCKSHIFT;
            int iInside = cp & BLOCKMASK;
            auto& blk = mBlocks[iBlock];
            ++blk.count;
            blk.data[iInside] = cf;
        }

        std::ofstream os("auto_casefold.cpp");
        os << "// This file is autogenerated!" "\n";
        os << R"(#include "detail/auto.h")" "\n";
        //os << "using Block = char32_t[" << BLOCKSIZE << "];" "\n";

        os << "constinit char32_t mojibake::detail::simpleCfBlocks["
                    << mBlocks.size() << "][" << BLOCKSIZE << "] = {" "\n";
        int currIndex = -1;
        int maxBlock = 0;
        for (auto& v : mBlocks) {
            // index
            ++currIndex;
            v.second.iArray = currIndex;

            maxBlock = v.first;

            os << " {";
            for (size_t j = 0; j < BLOCKSIZE; ++j) {
                if (j % 16 == 0 && j != 0) {
                    os << "\n  ";
                }
                os << v.second.data[j] << ',';
            }
            //os << v.first << " " << v.second.count << '\n';
            os << " }," "\n";
        }
        os << "};" "\n";

        ++maxBlock;

        os << "constinit short mojibake::detail::simpleCfLookup["
                    << maxBlock << "] {";
        for (int i = 0; i < maxBlock; ++i) {
            auto what = mBlocks.find(i);
            auto iArray = (what == mBlocks.end()) ? -1 : what->second.iArray;
            if (i % 16 == 0)
                os << "\n ";
            os << iArray << ",";
        }
        os << "\n" "};" "\n";

        return 0;
    } catch (const std::exception& e) {
        std::cout << "ERROR: " << e.what() << std::endl;
    }
}
